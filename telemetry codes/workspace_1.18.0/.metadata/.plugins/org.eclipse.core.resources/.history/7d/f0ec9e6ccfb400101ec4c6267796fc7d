/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "spi.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "nrf24l01p.h"
#include <string.h>   // for strlen, memcpy, memset
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

#define TRANSMITTER
//#define RECEIVER
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
uint8_t rx_data[NRF24L01P_PAYLOAD_LENGTH] = {0};
uint8_t tx_data[NRF24L01P_PAYLOAD_LENGTH] = {0, 1, 2, 3, 4, 5, 6, 7};
char data[128] = "<S>ID_1:32.5,ID_2:32.5,ID_3:28.0,ID_4:45.0,ID_5:30.0,ID_6:30.0,ID_22:20<E>";
uint8_t tx_payload[32] = {0};           // assume fixed 32-byte payload
uint8_t rx_payload[32] ;           // assume fixed 32-byte payload
float rx_lat = 0.0f, rx_lon = 0.0f;


/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
//void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
static void set_lat_lon_in_payload(char *data, size_t data_sz, float lat, float lon)
{
    float id1, id2, id3, id4, id5, id6,id22;

    // Parse the current values
    if (sscanf(data,
               "<S>ID_1:%f,ID_2:%f,ID_3:%f,ID_4:%f,ID_5:%f,ID_6:%f,ID_22:%f<E>",
               &id1, &id2, &id3, &id4, &id5, &id6,&id22) == 7)
    {
        // Overwrite ID_4 and ID_5 with lat/lon
        id5 = lat;
        id6 = lon;

        // Rebuild the string (%.1f -> one decimal like your sample)
        snprintf(data, data_sz,
                 "<S>ID_1:%.1f,ID_2:%.1f,ID_3:%.1f,ID_4:%.1f,ID_5:%.1f,ID_6:%.1f,ID_22:%f<E>",
                 id1, id2, id3, id4, id5, id6,id6);
    }

}


// Send len bytes in 32-byte NRF24 payloads
static void nrf_send_bytes(const uint8_t *buf, size_t len)
{
    size_t pos = 0;
    while (pos < len) {
        size_t n = (len - pos > NRF24L01P_PAYLOAD_LENGTH)
                 ? NRF24L01P_PAYLOAD_LENGTH
                 : (len - pos);
        memset(tx_data, 0, NRF24L01P_PAYLOAD_LENGTH);
        memcpy(tx_data, buf + pos, n);
        nrf24l01p_tx_transmit(tx_data);    // your driver call
        pos += n;
        HAL_Delay(2);                      // short gap between frames
    }
}


/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
  srand(HAL_GetTick());
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI2_Init();
  HAL_Delay(100);
  MX_USART1_UART_Init();
  /* USER CODE BEGIN 2 */

#ifdef RECEIVER
  	nrf24l01p_rx_init(2500, _1Mbps);
#endif

 #ifdef TRANSMITTER
	nrf24l01p_tx_init(2500, _1Mbps);
 #endif
	HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_2);

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	#ifdef RECEIVER
		  // Nothing to do
	#endif

	#ifdef TRANSMITTER



		  /* Test 1
		    for(int i= 0; i < 8; i++)
		  {
			  tx_data[i]++;
		  }
		  nrf24l01p_tx_transmit(tx_data);
		  uart1_send_raw(tx_data);
		  HAL_Delay(1000);
		   */

		  /* Test 2	*/
	  //Random float
//			int   lat10 = (rand() % 1801) - 900;    // step = 0.1
//			int   lon10 = (rand() % 3601) - 1800;   // step = 0.1
//			float lat   = lat10 / 10.0f;
//			float lon   = lon10 / 10.0f;
	  // Not ranndom
	  // Put these at file scope or as static inside your loop function
	  static int lat10 = 0;
	  static int lon10 = 0;

	  // Each time you need new values:
	  if (++lat10 > 100) lat10 = 1;
	  if (++lon10 > 100) lon10 = 1;

	  float lat = lat10 / 10.0f;   // 0.1 .. 10.0
	  float lon = lon10 / 10.0f;   // 0.1 .. 10.0

			memcpy(&tx_payload[0], &lat, sizeof(float));  // 4 bytes
			memcpy(&tx_payload[4], &lon, sizeof(float));  // next 4 bytes

			nrf24l01p_tx_transmit(tx_payload);

			set_lat_lon_in_payload(data, sizeof data, lat, lon);
			HAL_UART_Transmit(&huart1, (uint8_t*)data, (uint16_t)strlen(data), 100);
			HAL_Delay(6000);
	#endif



  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

	void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
	{
		if(GPIO_Pin == NRF24L01P_IRQ_PIN_NUMBER)
		{
	#ifdef RECEIVER
			// Test 1
//			nrf24l01p_rx_receive(rx_data);
//			uart1_send_raw(rx_data);
			//Test  2
			nrf24l01p_rx_receive(rx_payload);       // fills rx_payload

			// First 8 bytes are two floats: [0..3]=lat, [4..7]=lon
			memcpy(&rx_lat, &rx_payload[0], 4);
			memcpy(&rx_lon, &rx_payload[4], 4);
	#endif

	#ifdef TRANSMITTER
			nrf24l01p_tx_irq();
	#endif
		}

}


/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
	  HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);

  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
